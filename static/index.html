<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>InfraCrawl Control UI</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body { font-family: system-ui, Arial; max-width: 900px; margin: 24px auto; padding: 0 12px; }
      h1 { font-size: 20px }
      .card { border: 1px solid #ddd; padding: 12px; margin-bottom: 12px; border-radius: 6px }
      button { margin-right: 6px }
      table { width: 100%; border-collapse: collapse }
      th,td { text-align: left; padding: 6px; border-bottom: 1px solid #eee }
      pre { white-space: pre-wrap; word-break: break-word }
    </style>
  </head>
  <body>
    <h1>InfraCrawl</h1>

    <div class="card">
      <strong>Auth</strong>
      <div style="margin-top:8px">
        <label for="admin-token">Admin token:</label>
        <input type="password" id="admin-token" placeholder="Paste admin token" style="width:60%" />
        <button id="login-token">Login</button>
        <button id="logout-token">Logout</button>
        <span id="token-status" style="margin-left:8px;color:#666">Not authenticated on the static page</span>
      </div>
    </div>

    <div class="card">
      <strong>Configs</strong>
      <div style="margin-top:8px">
        <button id="btn-sync">Sync configs</button>
        <span id="sync-result"></span>
      </div>
      <div id="configs-container">Loading…</div>
    </div>

    <div class="card">
      <strong>Active Crawlers</strong>
      <div id="active-container">Loading…</div>
    </div>

    <div class="card">
      <strong>Recent Runs</strong>
      <div style="margin-top:8px">
        <button id="btn-clear-runs">Clear incomplete runs</button>
        <small style="color:#666;margin-left:8px">Mark recent incomplete runs finished and remove their data</small>
      </div>
      <div id="runs-container">Loading…</div>
    </div>

    <script>
      function getAuthHeader() {
        const t = localStorage.getItem('admin_token');
        return t ? {'Authorization': 'Bearer ' + t} : {};
      }

      async function fetchJson(path, opts={}) {
        opts.headers = Object.assign({}, opts.headers || {}, getAuthHeader());
        const r = await fetch(path, opts);
        if (!r.ok) throw new Error(await r.text());
        return r.json();
      }

      function formatStartedAt(ts) {
        if (!ts) return '';
        try {
          // Parse timestamp. If it's naive (no timezone), assume UTC.
          let s = String(ts);
          const hasTZ = /[zZ]$/.test(s) || /[+-]\d{2}:?\d{2}$/.test(s);
          if (!hasTZ) {
            // Normalize to ISO by inserting 'T' and appending 'Z'.
            s = s.replace(' ', 'T') + 'Z';
          }
          const d = new Date(s);
          if (isNaN(d.getTime())) return '';
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          const dd = String(d.getDate()).padStart(2, '0');
          const yyyy = d.getFullYear();
          let h = d.getHours();
          const ampm = h >= 12 ? 'pm' : 'am';
          h = h % 12;
          if (h === 0) h = 12;
          const hh = String(h).padStart(2, '0');
          const min = String(d.getMinutes()).padStart(2, '0');
          return `${mm}/${dd}/${yyyy} ${hh}:${min} ${ampm}`;
        } catch (e) { return '' }
      }

      async function loadConfigs() {
        try {
          const data = await fetchJson('/configs/');
          const el = document.getElementById('configs-container');
          if (!data.length) { el.innerText = 'No configs found'; return }
          let html = '<table><tr><th>config_path</th><th>pages</th><th>links</th><th>actions</th></tr>';
          for (const c of data) {
            // Fetch stats for this config
            let pages = 0, links = 0;
            try {
              const stats = await fetchJson(`/crawlers/stats/${encodeURIComponent(c.config_path)}`);
              pages = stats.pages ?? 0;
              links = stats.links ?? 0;
            } catch (e) {
              // If stats endpoint fails, just show 0
              console.warn('Failed to fetch stats for ' + c.config_path + ': ' + e.message);
            }
            html += `<tr><td>${c.config_path}</td><td>${pages}</td><td>${links}</td><td><button data-config="${c.config_path}" class="start">Start Crawl</button> <button data-config="${c.config_path}" class="remove">Clear Crawler Data</button></td></tr>`
          }
          html += '</table>';
          el.innerHTML = html;
          for (const b of el.querySelectorAll('button.start')) {
            b.onclick = async (ev) => {
              const cfg = ev.target.getAttribute('data-config');
              ev.target.disabled = true;
              try {
                const res = await fetchJson(`/crawlers/crawl/${encodeURIComponent(cfg)}/start`, { method: 'POST' });
                alert('Started: ' + JSON.stringify(res));
                // Refresh configs to update stats after starting a crawl
                setTimeout(loadConfigs, 1000);
              } catch (e) { alert('Error: ' + e.message) }
              ev.target.disabled = false;
            }
          }
          for (const b of el.querySelectorAll('button.remove')) {
            b.onclick = async (ev) => {
              const cfg = ev.target.getAttribute('data-config');
              if (!confirm('Remove all pages and links for ' + cfg + '?')) return;
              ev.target.disabled = true;
              try {
                const res = await fetchJson(`/crawlers/remove?config=${encodeURIComponent(cfg)}`, { method: 'DELETE' });
                alert('Removed: ' + JSON.stringify(res));
                loadConfigs();
              } catch (e) { alert('Remove failed: ' + e.message) }
              ev.target.disabled = false;
            }
          }
        } catch (e) {
          document.getElementById('configs-container').innerText = 'Error loading configs: ' + e.message;
        }
      }

      async function loadRuns() {
        try {
          const data = await fetchJson('/crawlers/runs?limit=20');
          const el = document.getElementById('runs-container');
          if (!data.length) { el.innerText = 'No runs'; return }
          let html = '<table><tr><th>run_id</th><th>config</th><th>start</th><th>end</th><th>exception</th></tr>';
          for (const r of data) {
            html += `<tr><td>${r.run_id}</td><td>${r.config_path ?? r.config_id}</td><td>${r.start_timestamp ?? ''}</td><td>${r.end_timestamp ?? ''}</td><td><pre>${r.exception ?? ''}</pre></td></tr>`
          }
          html += '</table>';
          el.innerHTML = html;
        } catch (e) {
          document.getElementById('runs-container').innerText = 'Error loading runs: ' + e.message;
        }
      }

      async function loadActiveCrawls() {
        try {
          const resp = await fetchJson('/crawlers/active');
          const data = resp && resp.active ? resp.active : [];
          const el = document.getElementById('active-container');
          if (!data || !data.length) { el.innerText = 'No active crawls'; return }
          let html = '<table><tr><th>crawl_id</th><th>config</th><th>started at</th><th>action</th></tr>';
          for (const c of data) {
            const id = c.id || c.crawl_id || '';
            const cfg = c.config_name ?? c.config_path ?? c.config_id ?? '';
            const started = c.started_at ?? c.start_timestamp ?? '';
            const startedStr = formatStartedAt(started);
            html += `<tr><td>${id}</td><td>${cfg}</td><td>${startedStr}</td><td><button data-id="${id}" class="cancel">Cancel</button></td></tr>`;
          }
          html += '</table>';
          el.innerHTML = html;
          
          for (const b of el.querySelectorAll('button.cancel')) {
            b.onclick = async (ev) => {
              const id = ev.target.getAttribute('data-id');
              ev.target.disabled = true;
              try {
                await fetchJson('/crawlers/cancel/' + encodeURIComponent(id), { method: 'POST' });
                setTimeout(loadActiveCrawls, 500);
              } catch (e) { alert('Cancel failed: ' + e.message) }
              ev.target.disabled = false;
            }
          }
        } catch (e) {
          document.getElementById('active-container').innerText = 'Error loading active crawls: ' + e.message;
        }
      }

      document.getElementById('btn-clear-runs').onclick = async () => {
        try {
          const cfg = prompt('Config path to clear (e.g. starkparks.yml):');
          if (!cfg) return;
          const within = prompt('Within seconds (optional, leave blank for no limit):', '3600');
          const body = { config: cfg };
          if (within && within.trim()) body.within_seconds = parseInt(within, 10);
          const res = await fetchJson('/crawlers/runs/clear', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });
          alert('Cleared: ' + JSON.stringify(res));
          loadRuns();
        } catch (e) { alert('Clear failed: ' + e.message) }
      }

      document.getElementById('btn-sync').onclick = async () => {
        const out = document.getElementById('sync-result');
        out.innerText = 'Syncing...';
        try {
          await fetchJson('/configs/sync', { method: 'POST' });
          out.innerText = ' OK';
          loadConfigs();
        } catch (e) { out.innerText = ' Error: ' + e.message }
      }

      async function testToken() {
        try {
          const r = await fetch('/crawlers/runs?limit=1', { headers: getAuthHeader() });
          return r.ok;
        } catch (e) { return false }
      }

      document.getElementById('login-token').onclick = async () => {
        let v = document.getElementById('admin-token').value.trim();
        if (!v) v = prompt('Paste admin token:');
        if (!v) return;
        localStorage.setItem('admin_token', v);
        document.getElementById('token-status').innerText = 'Checking token…';
        const ok = await testToken();
        if (ok) {
          document.getElementById('admin-token').value = v;
          document.getElementById('token-status').innerText = 'Authenticated (token saved in localStorage)';
        } else {
          localStorage.removeItem('admin_token');
          document.getElementById('token-status').innerText = 'Auth failed — token not saved';
          alert('Authentication failed — token invalid or server not configured with ADMIN_TOKEN');
        }
      }

      document.getElementById('logout-token').onclick = () => {
        localStorage.removeItem('admin_token');
        document.getElementById('admin-token').value = '';
        document.getElementById('token-status').innerText = 'Not authenticated on the static page';
      }

      // initialize token input/status from localStorage
      (function initTokenUI(){
        const t = localStorage.getItem('admin_token');
        if (t) {
          document.getElementById('admin-token').value = t;
          // verify token quickly
          testToken().then(ok => {
            document.getElementById('token-status').innerText = ok ? 'Authenticated (token saved in localStorage)' : 'Not authenticated on the static page';
          });
        } else {
          document.getElementById('token-status').innerText = 'Not authenticated on the static page';
        }
      })();

      loadConfigs();
      loadRuns();
      loadActiveCrawls();
      setInterval(loadConfigs, 30000);
      setInterval(loadRuns, 15000);
      setInterval(loadActiveCrawls, 5000);
    </script>
  </body>
</html>
